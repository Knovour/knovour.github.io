{"meta":{"title":"Knovour Notes","subtitle":null,"description":"個人筆記、心得","author":"Knovour Zheng","url":"https://notes.knovour.ninja"},"pages":[{"title":"About","date":"2017-10-13T17:11:49.018Z","updated":"2016-03-30T15:14:43.808Z","comments":true,"path":"about/index.html","permalink":"https://notes.knovour.ninja/about/index.html","excerpt":"","text":"Github 個人書櫃 簡歷 之前待過的 Blog Pixnet Blogger Logdown 友站連結 遊戲王的反主流學院"},{"title":"Tags","date":"2017-10-13T17:11:49.301Z","updated":"2016-03-21T13:01:15.111Z","comments":true,"path":"tags/index.html","permalink":"https://notes.knovour.ninja/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"個人的 CSS 習慣","slug":"my-css-habit","date":"2017-12-23T15:23:08.000Z","updated":"2017-12-22T16:53:22.588Z","comments":true,"path":"2017/12/23/my-css-habit/","link":"","permalink":"https://notes.knovour.ninja/2017/12/23/my-css-habit/","excerpt":"這邊紀錄一下個人寫 CSS 時的習慣，不是 BEM、ATOMIC 那些命名，只是紀錄程式的排列方式，有些我也還沒嚴格遵守，透過這篇整理來做為往後的參考。 紀錄不包含 postcss 的部份","text":"這邊紀錄一下個人寫 CSS 時的習慣，不是 BEM、ATOMIC 那些命名，只是紀錄程式的排列方式，有些我也還沒嚴格遵守，透過這篇整理來做為往後的參考。 紀錄不包含 postcss 的部份 樣式彼此有關聯的做 nesting忘記從哪篇文看到的，覺得不錯就習慣這樣了。 123456.class &#123; position: absolute; top: 0; left: 0; z-index: 10;&#125; 123456.class &#123; display: flex; align-items: center; justify-content: center; flex: 1; /* 這部份受上一層 DOM 的影響，所以不做內縮 */&#125; 123456.class &#123; background-image: ''; background-size: cover; background-position: center; background-repeat: no-repeat;&#125; 樣式排列順序 content：有 ::before 或 ::after 元件的話，如果有 counter- 之類會影響 content 的值就放在上面。 position - top、right、bottom、left、z-index：如果沒有 position 那其他相關的數值就佔這個位置。 display 與上一層的 display 有關聯的值。 width height margin border padding background box-shadow color 隨意，只是要分好類，比如 font- 開頭的放一起。 transform transition or animation 整體樣式如下12345678910111213141516171819202122232425262728.class::before &#123; content: ''; position: absolute; top: 0; z-index: 0; display: flex; justify-content: center; align-items: center; flex: 1; width: 100px; height: 100px; margin: 24px; border: 1px solid orange; padding: 24px; background-image: ''; background-size: cover; background-position: center; background-repeat: no-repeat; box-shadow: none; color: #333; /* 隨意 */ font-size: 12px; font-weight: bold; line-height: 1.2em; /* 隨意 */ transform: translate(50px); transition: all 200ms linear;&#125; 有想到其他的再補上，不知道 stylelint 能不能搞到這種程度。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://notes.knovour.ninja/tags/css/"}]},{"title":"轉轉徵人頁面開發記事","slug":"about-tenten-recurit","date":"2017-11-06T15:19:15.000Z","updated":"2017-11-07T12:17:51.765Z","comments":true,"path":"2017/11/06/about-tenten-recurit/","link":"","permalink":"https://notes.knovour.ninja/2017/11/06/about-tenten-recurit/","excerpt":"徵人頁面 這次的專案需求相對自由，不用管 IE 死活，對技術也沒特別要求，加上只有單一頁面，所以我決定用最單純的開發環境來進行。 主要架構 主框架：Polymer，用官方的 polymer-cli 創建專案。 輔助工具：Browsersync、SVGOMG（線上 SVG 壓縮工具） 沒有 webpack，只有用 polymer-cli 預設的指令打包壓縮。","text":"徵人頁面 這次的專案需求相對自由，不用管 IE 死活，對技術也沒特別要求，加上只有單一頁面，所以我決定用最單純的開發環境來進行。 主要架構 主框架：Polymer，用官方的 polymer-cli 創建專案。 輔助工具：Browsersync、SVGOMG（線上 SVG 壓縮工具） 沒有 webpack，只有用 polymer-cli 預設的指令打包壓縮。 開發過程基本上由於頁面單純的關係，沒有遇到 Polymer 比較深的坑，到是 css animation 眾多，導致在網頁效能上耗費許久，Chrome 沒有太大問題，然而 Firefox（57 beta 版）的 CPU 使用率卻降不下來，不得已只好先在 Firefox 下把部份動畫取消，但這幾天更新的版本似乎處理掉這個問題了，所以又重新把動畫給加回去，穩定版的就請自求多福。 Polymer 感想初次看時覺得很像 Vue.js，甚至覺得 Vue 如果能直接結合 web component 的技術應該也不錯。 摸索時最讓我困擾的，大概就是 CSS 作用域的控制，由於每個元件裡面的 html 元素都被 Shadow DOM 包裝起來，所以 css reset 起到的作用其實不大。但是 CSS 可以額外使用的功能很靈活，可以直接設定 var 值來把 component 預設值蓋過，不須透過 js 來傳參數，相對簡潔許多。在大致了解內建的 :host 與 ::slotted 的用法後，一樣的元件用 Polymer 做或許會比用 Vue 要來的簡潔。 開發期間唯一遇到一個算是坑的大概是初始 js 載入這件事，最一開始的頁面需要載入一支 webcomponents-loader.js 作為引導，在開發期間不會有什麼事，但打包之後卻無法在 Firefox 正常執行，得改成 webcomponents-lite.js 這支有加上 polyfill 的 js 才行。 Polymer 給我的感覺比較像是可以在一般專案裡，將複雜的元件剝出來獨立處理，而不是整個頁面都直接這樣開發，至於 Polymer 跟直接使用 web component 差別在哪，我目前也沒有頭緒。 最後對轉轉工作有興趣的人請跟我們聯繫吧！","categories":[],"tags":[{"name":"Polymer","slug":"Polymer","permalink":"https://notes.knovour.ninja/tags/Polymer/"}]},{"title":"Next.js 試用感想","slug":"try-next-js","date":"2017-07-18T15:29:59.000Z","updated":"2017-07-19T17:29:41.838Z","comments":true,"path":"2017/07/18/try-next-js/","link":"","permalink":"https://notes.knovour.ninja/2017/07/18/try-next-js/","excerpt":"在使用過 Vue 社群的 Nuxt.js 開發過一次專案後，便對 React 方的 Next.js 抱有很大的興趣，尤其在知道 Nuxt 是由此啟發之後，對他抱的期待又更高了，於是在專案上線後，就轉去摸索了 Next 幾天，來試試看能不能把很久之前的 React 專案搬到上面，以下大概講一下那段時間的心得。 以下以 3.0.1-beta.X 為主","text":"在使用過 Vue 社群的 Nuxt.js 開發過一次專案後，便對 React 方的 Next.js 抱有很大的興趣，尤其在知道 Nuxt 是由此啟發之後，對他抱的期待又更高了，於是在專案上線後，就轉去摸索了 Next 幾天，來試試看能不能把很久之前的 React 專案搬到上面，以下大概講一下那段時間的心得。 以下以 3.0.1-beta.X 為主 正文在我翻 Next 的 Readme 大概幾分鐘後，我瞄到了這個： 1&lt;Link href=\"/about\"&gt;&lt;a&gt;here&lt;/a&gt;&lt;/Link&gt; 我靠，Link 再包 a？認真？沒有人對這有意見嗎？我知道他的 Link 可以包其他元件當作事件綁定用，但有必要因為要讓其他元素也能切換網址就要這樣寫嗎？我得說這大概是第一個讓我在一開始就想放棄的東西。 後來我決定繼續弄下去，先來看看怎麼使用動態路徑，畢竟現在的網站越來越需要這樣做了。結果往下拉之後發現，已經要加入後端套件（Koa、Express）了嗎？我才剛開始半小時耶？什麼都還沒寫到耶？ 然而官方的範例只講到兩個網址互換不同的 pages 名稱，並沒有講到動態路徑怎麼處理，要看得要到他們的教學網站去看，而且得先登入才能看全部，搞什麼神秘？況且這教學網址只有在 Readme 前面提個一句就沒了，直接往下拉的話還真不會去注意到。 總之到最後總算是弄出來了，就像下面這樣： 12345// Koarouter.get('/jobs/:id', async ctx =&gt; &#123; await app.render(ctx.req, ctx.res, '/detail', ctx.query) ctx.respond = false&#125;) 1234&lt;!-- Next.js --&gt;&lt;Link href=\"/detail?id=123\" as=\"/jobs/123\"&gt; &lt;div&gt;job 1&lt;/div&gt;&lt;/Link&gt; 這看起來就像是為了實現這功能，而得繞了一圈才能回來的感覺，而且 href 跟 as 之間的內容看起來很不搭嘎，搭配後端一起看就像是個硬湊的方案一樣，後來看了一下 SEO 的部份，才知道他還得自己加上 react-helmet 來蓋過他自創的 Head 內容，這邊的實現方式看起來也像是繞了一圈才回來一樣。 而 Nuxt 則是實現了用資料夾結構與檔名關係來達成動態路徑的功能： 1234567pages/--| _slug/-----| comments.vue # /:slug/comments-----| index.vue # /:slug--| users/-----| _id.vue # /users/:id--| index.vue # / 到這邊之後，剩下的我基本上就草草看過就放棄了。後來原本的舊專案就改將他遷移到 react-slingshot 這個 webpack 架構上了，幸好這專案原本就沒有 SSR/SEO 的需求，所以不用太過在意。 感想到後來我才想到要去看 Next 究竟整合了社群的哪些東西，結果是一個也沒有（不算上 hot loader 那些東西），不論他的具體理由為何，我認為這是一件很蠢的事情。 開源社群基本上就是有個類似金字塔的模式：每個問題都有數種到數十種方案，到一定程度之後，就會出現幾個整合方案，再之後就會有更大型的多方整合方案，這些整合方案會從各種要解決的問題中取出他們認為適合的套件並使之成為預設功能。少部份不滿意的還是會自行製造一個輪子，但整體來說依然會有不少外部方案整合其中。比如在 Express 之上就有 Kraken.js、Sails.js 等整合方案，就算想自製輪子，至少也要讓他看起來像個樣子（比如 Sail.js 衍生出來的 Waterline）。 然而 React 社群是如此的活躍，在開發過程中你可能會遇到的問題裡，每個都有非常多的方案可以選，往好處想是選擇很多，但在如何選擇上也是一種困擾。然而在如此豐富的社群資源下，卻依然只做出自己專屬的輪子，而沒有進行整合，我能想到的就這兩個原因： 不想做或覺得沒必要做 React 社群的東西多但若要做多方整合則有很大的難度 前者是他們自己的問題，如果是後者那代表社群有很大的問題。 或許這些抱怨是在用過 Nuxt 之後，而對 Next 抱有過度期望所導致的失望，但在往後的選擇上，若是有 SSR 的需求，我會傾向於選擇 Nuxt，若沒有則會用一般的 React + Webpack 模板方案。 結論 以前我總認為既然先學了 React，那 Vue 其實沒有必要再多花心思在上面，直到我遇見了 Next。 總而言之，Next 給我的感受是，他們維護者的心態比較像：「我們做了這個東西，但我們自己內部夠用就好，你們來試試看（幫我們 debug）吧！」 而 Nuxt 的心態則是：「我們來做一個讓 Vue 社群可以方便開發的整合方案吧！」","categories":[],"tags":[{"name":"react.js","slug":"react-js","permalink":"https://notes.knovour.ninja/tags/react-js/"}]},{"title":"Vue.js 大型專案開發心得","slug":"something-about-tientien-frontend-development","date":"2017-05-18T17:30:00.000Z","updated":"2017-05-18T17:40:19.068Z","comments":true,"path":"2017/05/19/something-about-tientien-frontend-development/","link":"","permalink":"https://notes.knovour.ninja/2017/05/19/something-about-tientien-frontend-development/","excerpt":"歷時數月的田田蔬果終於正式上線了。 這次專案是用 Vue 作為主軸來進行開發，對公司以及對我來講，不只是第一次的體驗，也是第一次將此類技術直接用在一個完整專案，來達到前後端分離的目標。","text":"歷時數月的田田蔬果終於正式上線了。 這次專案是用 Vue 作為主軸來進行開發，對公司以及對我來講，不只是第一次的體驗，也是第一次將此類技術直接用在一個完整專案，來達到前後端分離的目標。 好的方面挑選 Vue 的原因，不外乎是因為容易入門，而 html、js、css 三種語言雖然在同一檔案，但各自分離，對第一次入門的人比較容易看懂。二方面是公司裡的前端，除了我以外都是設計轉工程師，對於轉向更加系統化的開發架構這方面，Vue 也會是更好的選擇。故在參與開發的同時，我也負責將其他前端帶入門，以及一些 ES6 的基礎教學；Vue 的文件清晰易讀，函式也容易理解，所以在帶入門後，他們也很容易從文件中獲取他們所需要的資訊。 在開發期間，有其他工程師進來幫忙一小段時間，也有工程師離職，到最後我得承擔整個前端的開發，在看過並整理其他同事寫的部份花了我不少時間，但跟整理一般的麵條式程式碼比起來，比較不容易攪亂思緒。 Nuxt 的出現是個即時雨，對於各方面來講都有很大的幫助，不僅省下不少折騰 Webpack 的時間，也是社群裡對 SSR 支援最好的方案，加上自動建立 route、code split 等，都是前端 library 開發的痛點之一，轉移到 Nuxt 之後，著實省下不少麻煩。 壞的方面在決定用 Vue 開發時，第二版大概出了好一陣子，但到後來才發現，有不少套件都停留在第一版沒有跟上，這在當下是個挺大的麻煩，雖然有原生 js 方案可選，但用起來就是比較彆扭；也由於第二版推出時間不算久，所以開發過程中，也會跟著版本進行升級，但有時可能因為一個小變動，而讓一些本來寫好的功能變得無法作用，事情就會變得更麻煩。 Nuxt 雖然幫上很大的忙，但畢竟不是正式版，坑也非常得多。有時 bug 一出現，你很難確定到底是 Nuxt 的問題，亦或是 Vue 的問題，當下除了幹聲連連外其實也很懶得去追究這件事。不過在許多方面，Nuxt 的出現解決很多問題這是肯定的，所以專案結束後，我也贊助了一些給他們。 這邊列幾個我遇到的很鳥的 bug 本來點擊 logo 是回到首頁，但在某些頁面底下，點了 logo 卻會回到上一頁，幸好更新了版本後就沒這鳥事了。 有些 router link 在 Chrome 的 devtool 底下沒有顯示連結，但點了是有反應的。 Nuxt 在 0.9.7 到 0.9.8 之間多了非常多關於 route 的測試與功能等相關的 commit，結果 0.9.8 出來時，route 是壞的，遇到的當下讓我心情實在是糟到不行。 回報 issue 的當下其實是很想罵人的 個人感想在碰 Vue 之前，我已經用 React 寫過幾個小專案了，所以我對於多學一樣都是 view 方面的 library 興趣實在不大。 因為之前寫 React 的時候，我才意識到前端最麻煩的其實是事件的流程處理，jQuery、純 js 之類的自然不用說，基本上是最難統整的，但以前寫的時候卻不會對這部份多想；雖然 React 有 Redux，Vue 有 Vuex，對於開發流程也有很大的幫助，但總覺得缺少了什麼，所以有考慮要接觸 RxJS，後來跳去摸 Elm，而 Elm 的方式大概是我目前遇到覺得最好的，可惜是個冷門的領域。 這次專案開發的過程中，不只是上述壞的方面，其他與 Vue 無關的坑也不少，尤其是 Safari 的種種鳥事，雖然每個功能都有實現，但都只有實現一半，你踩到算你衰。IE 已經不再更新，你只能自己摸摸鼻子，而 Safari 更新緩慢支援又差，在這次專案後已經把他跟 IE 徹底劃上等號了。 整體來說，我對 Vue 的感受其實是很差的 XDD，除了容易上手這點外，我覺得也就只有這點了，只能說很抱歉剛好在不上不下的時機進場，結果搞得七葷八素，加上跟他無關的鳥事也超多，每次回想總是會想到一塊，就會覺得很煩躁阿… 收穫與教訓 不要對社群的套件跟上新版本的速度抱持樂觀（不如說這是選新技術時也得考量到的）。 前後端分離後，RESTful API 的設計以及響應的速度更加重要。 下次弄個 Prettier 好了。 有些套件還是會暗藏 jQuery，不可不慎（不是說 jQuery 不好，但既然用了其他前端 library，那他就不該是列入的項目）。 函數式才是往後 js 開發時，最需要了解的核心觀念。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://notes.knovour.ninja/tags/Vue/"}]},{"title":"摸索 Elm","slug":"elm-practice","date":"2017-01-21T13:50:05.000Z","updated":"2017-05-13T11:04:02.225Z","comments":true,"path":"2017/01/21/elm-practice/","link":"","permalink":"https://notes.knovour.ninja/2017/01/21/elm-practice/","excerpt":"前陣子在考慮摸索 Elm，剛好在那時候也在找當季蔬果的資料，後來想想，乾脆用這些資料來當作摸索的題材，於是這網站就誕生了，以下來大概講一下感想。 當季蔬果一覽 GitHub 選 Elm 的原因很大一部份其實是逃避現實，由於 JavaScript 的 framework 跟 library 大量出現，而且不僅是前後端，還延伸到桌面軟體、APP 甚至是 IoT 上。以前只是將 ES6 轉成 ES5 的 Babel，現在除了將可能會有的 ECMAScript 語法轉換以外，還可以讓 JS 支援一些不存在的語法（比如 Flow），再配上 webpack 還可以進一步定義更深的語法結構，雖然不是說非得全包全學不可，但五花八門的輪子不斷冒出，當下感覺是非常的吃不消。 當時摸的是 React，雖然我個人挺喜歡這 library JSX 語法我很討厭，加上圍繞著 React 衍生的各種有的沒的花樣，輕則只是加點功能，重則有如在這之上又加了自創的語法一般，導致整個檔案看起來就像是三四種語言或語法風格的大雜燴，但不得不說，React 生態系真的把 JS 玩得很溜，比如 styled-components 又是一絕，但又要多塞一種風格在裡面我得考慮考慮。 原本下一個想碰的是 Cycle.js，但後來想想，Redux 跟 Cycle.js 都有跟 Elm 借鑒一些東西，加上繼 Redux 出現之後，Elm 被關注的程度似乎有上升的趨勢，不如就直接學 Elm 看看，而這也是我第一個學的轉 JS 的語言。","text":"前陣子在考慮摸索 Elm，剛好在那時候也在找當季蔬果的資料，後來想想，乾脆用這些資料來當作摸索的題材，於是這網站就誕生了，以下來大概講一下感想。 當季蔬果一覽 GitHub 選 Elm 的原因很大一部份其實是逃避現實，由於 JavaScript 的 framework 跟 library 大量出現，而且不僅是前後端，還延伸到桌面軟體、APP 甚至是 IoT 上。以前只是將 ES6 轉成 ES5 的 Babel，現在除了將可能會有的 ECMAScript 語法轉換以外，還可以讓 JS 支援一些不存在的語法（比如 Flow），再配上 webpack 還可以進一步定義更深的語法結構，雖然不是說非得全包全學不可，但五花八門的輪子不斷冒出，當下感覺是非常的吃不消。 當時摸的是 React，雖然我個人挺喜歡這 library JSX 語法我很討厭，加上圍繞著 React 衍生的各種有的沒的花樣，輕則只是加點功能，重則有如在這之上又加了自創的語法一般，導致整個檔案看起來就像是三四種語言或語法風格的大雜燴，但不得不說，React 生態系真的把 JS 玩得很溜，比如 styled-components 又是一絕，但又要多塞一種風格在裡面我得考慮考慮。 原本下一個想碰的是 Cycle.js，但後來想想，Redux 跟 Cycle.js 都有跟 Elm 借鑒一些東西，加上繼 Redux 出現之後，Elm 被關注的程度似乎有上升的趨勢，不如就直接學 Elm 看看，而這也是我第一個學的轉 JS 的語言。 心得除了剛開始完全不知道怎麼下手外，整體寫起來的感受還算是不錯的，一開始讓我最欣賞的就是程式的引入方式，免去了引入時要寫 ../../ 之類相對路徑的麻煩。 12-- Components/Header.elmmodule Components.Header exposing (..) 12-- Somewhere elseimport Components.Header exposing (..) Pipeline 似乎是大部分函數式語言都會有的東西，不過第一次使用時是覺得也是挺有趣的部份，避免掉小括號連包的情況。在 JS 底下類似鏈式寫法，只是某些地方可能得再自己寫個 prototype 接起來或是直接用 lodash 之類的比較快。 12num = 1multiply(4, add(1, num)) 1234-- Same asnum |&gt; add 1 |&gt; multiply 4 Elm 既是一門語言，也是一個 framework，所以建立 HTML 的部份也不會顯得突兀，這部份也是 Cycle.js 參考的地方，跟 JSX 比起來，也比較不會有那種 JS 跟 XML 塞在一起充滿嚴重違和感的感覺。 12345678910div [ class \"search-bar\" ] [ label [ class \"label material-icons\", for \"search\" ] [ text \"search\" ] , input [ id \"search\" , type_ \"search\" , name \"search\" , placeholder \"Search...\" , onInput (\\value -&gt; SearchMsg &lt;| Name value) ] [] ] 而 Redux 則是參考了 Elm 的事件處理方式，也就是 The Elm Architecture 的部份。 一些困擾的地方額外的 library 太少，或沒跟上新的版本這大概是冷門語言最現實的地方，當初想找個線上資料庫之類的服務把當季蔬果的資訊存進去，本來找了 Firebase，但相對應的 elmfire 卻是卡在支援 Elm 0.16 版遲遲未更新。之後想改找 GraphQL 的服務，但 elm-graphql 不管試了幾個服務都沒法接上。由於希望能先把網站做出來，所以後來直接丟 Contentful CMS 用直接 call 網址的方式取資料。 View 自訂 component 時，語法風格沒法統一我在寫 React 時都盡量讓 XML 的區域只出現 XML，而不是中間又插個 JS 搞得更不倫不類，而 Vue 已經把兩個分開，所以不太需要擔心這種事，但 Elm 的一個標籤兩個陣列的寫法我反而很難配合寫出一樣的銜接 component 的方式。 如果只是單純的資料傳遞還算勉強有方法，但加上事件處理流程後就很難這樣辦了。 沒有 null有些語言回傳空值是沒在用 null 的，取而代之的是用額外的 package（Elm 是取名叫 Result）再包裝一遍，然後再把值取出來。這事已經在 Rust 見試過一次了，雖不討厭但還沒適應這寫法就是。 其他一些晦澀的地方文件有些地方沒有付範例還蠻難看懂的，比如當我想用 Dict.map 這個函式時，描述所寫的： 1234map : (comparable -&gt; a -&gt; b) -&gt; Dict comparable a -&gt; Dict comparable b 我是怎樣也看不明白，後來翻到這篇文章時才知道原來是要這樣子寫： 1Dict.map (\\key value -&gt; do something) data 另外像程式碼報錯的部份，我最常被指出的錯誤是函數的接收或回傳的型態描述不對，而他會很貼心的建議你應該是要寫另外一種，但他建議的照做之後有時又會錯得更厲害，彷彿被愚弄了一樣，尤其 Elm 的型態不是只有 Int、String、List 之類常見的型態，還可以自訂其他的型態，再加上 The Elm Architecture 的架構，初學時在多方來往之間，有時一個小地方搞混可能得找老半天才知道真正的問題是什麼，而那個答案也不會是當初 Elm 檢查時所給你的建議。 其他一些像 main program 的 Program Never Model Msg 這奇怪的描述，到最後是完全不想懂了。 後話老實說，在寫的期間，曾有數度想要推掉用 JS 重寫的衝動，並不是越寫越討厭的關係，而是一方面從 JS 這類語言回頭去學嚴謹的語言會有不少困難，另一方面還是會有「反正到頭來都是轉回去 JS，學這幹麻？」的念頭在。但在寫的過程中，文件的描述以及途中尋找一些 library，期待他至少「堪用」但沒想到是「沒法用」的情況下，也是加深重寫的想法的原因之一。 最大的收穫大概是對函數式的寫法有更多的經驗，雖然平常寫 js 就會盡量以函數式的方式寫，但不會每個 function 都拆分得乾乾淨淨，離嚴格遵守有很大的距離，在被 Elm 逼著你這樣思考這樣寫之後，對往後寫 js 的程式架構分配也會有很大的幫助。 至於 Elm 會不會變流行？我覺得不會，畢竟 JS 的生態圈裡不只 framework 跟 library 氾濫，連可以轉成 JS 的語言數量也氾濫無比，隨著 ES6/7 正式上線，以及 ES8 開始規劃支援後，選用非 JS 的語言再轉換這件事就更加沒有必要了，更何況那一票套件也是都要用自己的 webpack loader 做轉換才能動了！ 但如果 WebAssembly 開始正式推行的話，或許會有不一樣的氣象也說不定，我想到時除了為了寫遊戲而使用 WebAssembly 的語言外，像 Elm 這種獨立語言 + framework 的語言也會跟著變多吧！ 至少我不太會想拿來寫第二個網站就是… 結論Always bet on js - by Brendan Eich（JS 之父）。","categories":[],"tags":[{"name":"elm","slug":"elm","permalink":"https://notes.knovour.ninja/tags/elm/"}]},{"title":"這幾年使用 Linux 當一般作業系統的感受","slug":"years-of-using-linux","date":"2016-07-08T04:19:39.000Z","updated":"2017-05-18T16:59:12.193Z","comments":true,"path":"2016/07/08/years-of-using-linux/","link":"","permalink":"https://notes.knovour.ninja/2016/07/08/years-of-using-linux/","excerpt":"上圖是我的 Linux 現在的樣子： 發行版：Manjaro Linux 桌面環境：KDE 5 Plasma 佈景：Maia Theme Linux 在我大學期間就開始嘗試拿來作為一般的作業系統使用，但那段期間其實一直都在 Windows 跟 Linux 之間切換（你知道的，遊戲），後來這兩年開始固定用 Linux，工作時用 Mac，基本上已經沒怎麼碰 Windows 了。 當然，這個過程並沒有讓我成為什麼 Linux 大師，我也沒有這個打算，只是嘗試能在日常生活中使用而已。前一陣子看到這篇文章後覺得很有趣，於是決定也來寫篇自己的經歷以及感受。以下我會將這篇文章分成數個大項目來做探討。 裏面一些資訊可能與印象有所不同，請見諒。","text":"上圖是我的 Linux 現在的樣子： 發行版：Manjaro Linux 桌面環境：KDE 5 Plasma 佈景：Maia Theme Linux 在我大學期間就開始嘗試拿來作為一般的作業系統使用，但那段期間其實一直都在 Windows 跟 Linux 之間切換（你知道的，遊戲），後來這兩年開始固定用 Linux，工作時用 Mac，基本上已經沒怎麼碰 Windows 了。 當然，這個過程並沒有讓我成為什麼 Linux 大師，我也沒有這個打算，只是嘗試能在日常生活中使用而已。前一陣子看到這篇文章後覺得很有趣，於是決定也來寫篇自己的經歷以及感受。以下我會將這篇文章分成數個大項目來做探討。 裏面一些資訊可能與印象有所不同，請見諒。 作業系統我第一個用的 Linux 發行版是 Ubuntu 7.10，當時 Compiz Fusion 這個桌面特效大補帖的相關影片出現時小紅了一陣子，我也是在那時候知道 Linux 以及其中的 Ubuntu。我已經忘記當時看到的影片是哪個了，不過就是如下面的影片所呈現的那樣。 那段期間打開 Ubuntu 之後，也不過就是玩一玩特效、隨便打幾個指令、開 Firefox 晃一下就切回去玩遊戲了，沒辦法，這就是 Windows 最大的優勢。 到大二的時候，原本的電腦寄回老家，我再另外買一台基本配備的套裝主機，那時候 Vista 剛推出，而我也不疑有他直接用預設的。 誰知道這正是噩夢的開始。 當時那台主機記憶體只有 1GB，但光 Vista 本身居然就吃了 70% ~ 80% 的記憶體，隨便晃個滑鼠、開個視窗，記憶體要過 90% 都不是問題。在這情況下，這作業系統根本是沒辦法用的，不只吃記憶體，而且極端的不穩定，雖然後來多插了記憶體以及幾次系統更新後症狀逐漸減輕，但從那時候開始，我在空閒時折騰 Ubuntu 的次數反而大幅增加了。 比起 Vista，Ubuntu 裝上之後記憶體只吃了 20% ~ 30% 左右，開特效也沒有什麼大問題，但自從 8.04、8.10 版本推出之後，問題也開始多了。我還蠻執著於軟體什麼都要到最新版才行，所以新版本推出之後我也就升級了，但版本上到 8 之後，一切都不那麼美好了。半年一次的版本升級基本上就是個災難，直接升級的後果會讓 Ubuntu 有一堆奇奇怪怪的問題，與其花時間找方法解決這些問題，直接用新版重灌取代升級反而是最好的方法；當然，如果只要半年重灌一次就可以解決那到還好，怎樣都不會比我重灌 Vista 的次數多。但 Ubuntu 的軟體、library 版本不上不下，也稱不上穩定，在系統更新個幾次之後又開始有奇怪的問題了。 那時 Ubuntu 給我的感受是：我有的問題別人不一定有，別人有的問題我基本上都會有，但別人提供的解決方式起碼有一半在我這邊行不通。 拜這所賜，當時我覺得我的 Google 搜尋能力得到了提升，而主打一般人也能使用的 Linux 反而變得很常與指令、系統 config 打交道。所以想學好 Linux 基礎的話，去被 Ubuntu 惡整搞不好是最快的方式，這是我折騰到後面的感想。也因為如此，在我心目中最穩定的 Ubuntu 版本是 7.10（當然我也不算是很頻繁的用他），而在架伺服器時，我通常會先考慮 CentOS 或 Scientific Linux，Ubuntu Server 反而不會是我優先考慮的發行版。 後來有次在 Ubuntu 上當一次機之後，每重開機一次就有某個系統設定或某個軟體設定被初始化，重開越多次，就會越像系統剛裝好的樣子。在那場悲劇之後，一怒之下我就跳槽到 ArchLinux 了。 在此掛上 8.10 的桌布來紀念那段日子（這也是歷來 Ubuntu 版本裡，我最喜歡的預設桌布） 當時看到這篇 ArchLinux 推廣教學文時就一直考慮要換，看了幾次教學文以及搜尋其他教學文章跟 VM 練習之後才下定了決心。要知道，那時候智慧型手機還沒有推出，手機上網也是件不容易的事，所以當時我把過程抄在紙上後，燒了光碟就開始弄了。當時的安裝過程就跟那篇推廣文的內容差不多，有基本的引導流程，所以沒有很大的麻煩（其實我不小心把 D 槽給格式化了）。 ArchLinux 裝完後問題其實也不少，但有很完整的 Wiki 在，基本上都是可以解決的事，就算要額外搜尋，也不太會有別人的解決方式我行不通的情形發生，雖然安裝過程麻煩了一些，但重灌的次數少了非常多。話雖如此，ArchLinux 的開發者卻覺得應該要提高安裝的難度，所以新版連基本的安裝導引都拿掉了，你得從頭到尾打指令才行。 第一次重灌時覺得算了，反正久久才會重灌一次，等到那個「久久」的時刻真的來臨時，我反而沒什麼耐心再搞安裝了。在這之前有搜尋過 ArchLinux 的衍生版，其中 Chakra 以及 Manjaro Linux 是比較常看到有在討論的，安裝上也比較方便，在試了幾次 Chakra 都無法安裝成功後，我選擇了後者直到現在。 桌面環境Linux 的桌面環境基本上就是 Gnome 跟 KDE 這兩個為大宗，前者基於 GTK，後者基於 Qt，一個是以 Mac 桌面環境為參考，一個是以 Windows 為參考；在版本前進到 Gnome 3 以及 KDE 4 之後，兩者都開始走出屬於自己的路了。 當時 Ubuntu 是以 Gnome 2 為預設環境，8.10 以前是以淺色為基調 來源：Softpedia 基本上看起來就是很無聊的樣子，到 9.04 時換成深色佈景，質感提升了不少。 來源：Softpedia 但對我來說他還是有個問題 ― 他很好看，但不耐看，看了差不多三個月之後就看膩了。在那段期間，除了折騰系統上的問題之外，我還深深陷入了更換佈景及調整桌面配置的過程中；只要在 RSS 上看到有什麼 Gnome 佈景推荐的文章，或是像 GNOME-LOOK.ORG 之類的網站看有什麼不錯的佈景，我就會抓下來試一試。 這些佈景在試用後的感想是：深色系的普遍都不好看也不耐看，淺色系的有些雖不好看但還算耐看。 而那時在我的作業系統上留最久的佈景應該是 Bamboo Zen。 來源：GNOME-LOOK.ORG 當時有一部份 Gnome 的淺色系佈景很喜歡打上一種噱頭：像 Mac 一樣。我不懂為什麼很多人想要讓作業系統看起來「像 Mac 一樣」，但他真的發生了。他們把色彩調成淺銀色或銀白色，加上點光澤，換掉圖標（我覺得在這當中最可憐的是 Firefox，因為他常被迫換上 Safari 的圖標），一個 Mac Like 介面就誕生了。在這段期間，最嚴重的莫過於誕生了 Pear OS 這個發行版。 來源：Softpedia 不論這些像 Mac 一樣的佈景有多麼強調這件事，他們唯一不會跟你講的就是：「當你裝好之後，切記！盯著桌面看就好，不要做任何事，不要打開任何東西。」，因為隨便點開一個視窗就徹底破功了。這種事在 Android 上也在發生，只是模仿對象變成了 iOS。 不過 Pear OS 已經收掉了，目前的 Mac Like 發行版變成 GMac Linux。 至於 Ubuntu 自己的 Unity 介面我就不知道要說啥了… 鏡頭切到 KDE 這邊，當時 KDE 3 我覺得沒什麼特色，完全沒有想用的慾望；但是當 KDE 4 推出之後，整個感受都不一樣了，不僅好看，而且耐看。在那之後推出的 Windows 7 更被調侃是「抄襲 KDE 4」，而後來 KDE 也很不客氣的把 Windows 7 上一些特色給抄了過來（比如拖拉標題到邊邊讓他佔半個螢幕）。所以在我跳槽到 ArchLinux 時，我也改用 KDE 作為我的桌面環境。 這是當時的樣子：ArchLinux + KDE 4 KDE 好看歸好看，但還是得說，他從來沒有穩定過。並不是說用到一半就會全面崩潰之類的（早期倒是很頻繁），但總是會東壞一點西壞一點，雖不影響正常使用，但總是有疙瘩。 後來 KDE 5 Plasma 推出，整體而言又更上了一層，但還是一樣，他從來沒有真正穩定過，至少現在問題已經少非常多了。 這是 KDE 5 Plasma 的預設佈景 有一個主打 Material Design 的桌面環境 Papyros 還在開發中，等穩定的時候再來試試看。 來源：YouTube 題外話：如果想要找個節省資源的桌面環境，比起 Xfce，我會比較推荐 LXQt，至於其他一些比較硬派的桌面環境，我的興趣就不大了。 開發工具一開始把玩過一下 Emacs，後來在 Vim 上使用了一段不算短的時間，然而最終我還是沒能掌握那一堆快捷鍵以及指令的精髓，要是逼我使用 60% 鍵盤，我大概會瘋掉。那時大學時學的語言還是以 Java 為主，所以 Eclipse 等 IDE 還是比較常使用的，曾經看過一名同學在 Eclipse 上用快捷鍵用得嚇嚇叫，讓我十分佩服，雖然最後他被當了。 工作之後開始使用 Mac 跟 Sublime Text，在開發 web 挺方便，缺點是在 Linux 底下無法打中文，不管打什麼補丁、用什麼方法都不管用，不過當時也沒有比較好的替代品，所以在 Linux 底下還是只能將就。之後 Atom 推出 Beta 測試，不算上他用起來像 Alpha 這件事，光是能好好打中文就謝天謝地了，在推出測試之後就立馬換上。再之後推出正式版時，Visual Studio Code 推出了，這編輯器在使用上感覺比 Atom 舒服不少，所以在試用一陣子之後就又換了。將來會不會又想跳哪個編輯器我也不知道，不過 Spacemacs 頗讓我感興趣的，前提是我有沒有心想記那一堆快捷鍵… 硬體支援顯卡就是挑 NVIDIA，驅動在 Linux 上的支援度比 AMD 好太多太多了。一些小東西比如無線網卡之類的，不要挑功能太多或看起來好像很高檔的，不然就算有幸找到支援的驅動，在抓取硬體時很可能也會是這次有抓到，但下次就不一定了。 軟體如同 Gnome 與 KDE 之爭一樣，軟體開發的 GUI Library 也是以 GTK 跟 Qt 為主流，少部份會用 Tcl/Tk 之類的東西。不過不論是用哪種 Library，最困難的一點莫過於跨平台這件事，基本上有跨平台又好用的軟體少之又少，而在跨平台之中，每個都能有一樣的使用體驗更是難上加難。 一些像 Krita、Blender 跟 LibreOffice 之類的軟體都能在三個作業系統上有不錯的體驗，而 GIMP、MyPaint 在 Windows 及 Mac 平台上有時會因為編譯問題而延遲發佈，穩定性也稍微低一點，至於 Inkscape…他連在 Linux 上都不一定穩定了。誠心建議，如果想在非 Linux 平台使用 GIMP 跟 Inkscape 的話，可到這個網站下載另外編譯打包好的版本，執行起來相對穩定許多。 而有些企業會突然宣佈產品支援 Linux，比如 Xara Xtreme，在宣佈支援的時候可是歡騰了一小陣子，畢竟除了 Inkscape 外沒有什麼強大的替代品可供挑選，然而在更新幾個小版本後就已經沒有任何維護了；要不然就是像 Foxit Reader 那樣，維持最低限度的更新。 圖片來源：Xara Xtreme 在這幾年裡，Electron 開始流行，很多服務開始用「包著網頁當軟體」的方式來實現跨平台，如果打一開始就這樣推出的話到不是什麼問題，但如果是中途變更可能反而會造成反效果。 比如像 Linux 上的 Skype，簡直就像是半個僵屍一般，在 Linux 上破破爛爛的，當 Windows 跟 Mac 都換上新介面的時候，只有 Linux 版在被收購那一陣子換上微軟大大所有、加上微軟帳號登入後就不再有任何更新，不論官方論壇上的人有多憤怒，聽不到就是聽不到。 然而前幾天微軟突然發佈一個好消息，宣佈 Linux 版 Skype 重新製作的 Alpha 版測試，這基本上就是個大消息，之前他在表面上說自己有多麼積極擁抱 Linux 的時候，Linux 版的 Skype 默默的躺在一邊啜泣，而現在卻又重獲關注，多麼棒的消息！ Skype 的 GUI 是基於 Qt，但是在裝上 Alpha 版之後發現，怎麼捨棄了 Qt 用上 GTK 了？打開後的直覺是這應該是 Electron 打包的（Electron 基於 Chromium，Chromium 基於 GTK），Reddit 以及一些文章也有提到這件事；雖然 Visual Studio Code 也是 Electron 打包的，用起來也不錯，但 Skype 這種作法實在是太忽悠人，畢竟有四五年沒有任何更新。尤其在這之前已經有許多人嘗試用這種方式打包網頁版了，其中有些運作得還不錯，微軟真的沒有直接拿別人的程式碼來改？再一次，微軟又讓人失望了。 Ghetto Skype, base on Electron（人家還可以選佈景勒） 很多時候，在 Linux 上使用軟體真的覺得自己像個次等公民一樣，但現在 web 技術愈來愈發達，很多東西已經都是改在網頁上完成，所以這個隔閡就顯得比較不那麼嚴重了（但微軟還是該死）。 遊戲拜 DOOM 系列遊戲 Open Source 所賜，以前 Linux 上 3D 大型遊戲裡佔絕大多數的就是 FPS 類遊戲，其他的就是一些像 SuperTux 之類的 2D 小遊戲，沒有什麼能夠提起興趣的，主要還是開 Windows 打魔獸三國之類的居多。 後來 HoN 推出，第一款不用魔獸三就能獨立執行的 Dota 類遊戲，而且還支援 Linux，在玩過幾次之後就慫恿朋友也跟著跳坑，但無奈官方希望能夠用收費的方式經營，在歷經一年多的免費暢玩後，遊戲收費的第一天，人氣直跌谷底，分別回流到原本的魔獸與那時剛推出不久的 LoL，過幾年後 Dota2 推出，我也就這樣轉戰過去了。幾年之後，HoN 默默改回免費模式，但已不再吸引人了。 之後開始工作時，玩的遊戲也變少了，通常都是周末時才會開 Windows 打一下 PoE 或 Dota2，當時我跟我朋友開玩笑說：「如果兩款其中一款出了 Linux 版，那我大概就不會再切到 Windows 了」。在大約又快一年之後，Valve 開始全力推廣 Linux 遊戲，首先就將 Dota2 與 CS:GO 等旗下遊戲轉移到 Linux 上，從那時起，我自己的電腦就再也沒開過 Windows。 時至今日，Steam 上面的 Linux 遊戲愈來愈多，個人的收藏庫裡有過半是有支援 Linux，之後有空再來考慮怎麼玩那些 Windows 的遊戲。 以下是我遊戲收藏庫裡支援 Linux 的部份： 最後說一點 Mac雖說是因為工作需求而買了 Macbook Pro，但那時對 Mac 實在沒有什麼感覺，只是覺得「有一天應該會需要用 XCode 寫 APP 吧」，所以對當時的我來說，就像是花了幾萬塊買了 XCode，但卻從來沒用過的感覺。 用了幾年基本上除了覺得觸控版做得很棒之外，真的沒有什麼很特別的評價，不討厭也沒特別喜歡。不過上面的軟體倒是有不少挺喜歡的，比如 Sketch、Affinity Designer 等等，如果往後要說我為什麼會用 Mac 的話，大概會是因為上面有我喜歡的軟體吧（有 Linux 版我會很願意再花一次錢…，前提是功能要能完整體驗）。 結論 感謝 Vista 讓我的人生有了轉折，其次是 Ubuntu（？ Windows 上可以互相取代的軟體非常多，如果有人又在拿 GIMP 之類的說你或許不需要用 PS 云云，我建議你不妨先試試例如 Paint.NET 之類的替代方案，或是上 AlternativeTo 找找看。 真的想用 GIMP 或 Inkscape 的話，這個網站編譯打包的比較穩定。 Linux 推廣勸世文看看就好。 真的被勸成了也別挑 Ubuntu，挑 Linux Mint 之類的 Ubuntu 衍生版比較穩定。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://notes.knovour.ninja/tags/Linux/"}]},{"title":"React/Redux 一個月的開發感想","slug":"my-experience-about-react-redux-in-one-month","date":"2016-05-23T12:05:22.000Z","updated":"2017-05-13T11:04:11.215Z","comments":true,"path":"2016/05/23/my-experience-about-react-redux-in-one-month/","link":"","permalink":"https://notes.knovour.ninja/2016/05/23/my-experience-about-react-redux-in-one-month/","excerpt":"之前自學 React 時寫了一個簡單的線上簡歷，而我也確實靠他加分而拿到了工作，之後進去也是開始用 React 建立頁面，之後加上了 Redux；雖然這兩個總天數加起來大概就一個月，不敢說自己有摸清這些東西，不過還是就開發經驗來寫一些感想。 先講結論對 React 其實不討厭，還算是喜歡的；但若是要我向別人推荐的話，我會建議學 Vue.js 入門，熟了再考慮要不要碰 React。若是不排斥用其他語言轉換成 js 的話，Elm 看起來是個不錯的選擇，但 ES6 開始普及之後我對這方面的興趣不大，所以這個建議比較不負責任一點。 摸新東西當然都會面臨挫折、觀念轉變以及學習曲線的問題，但事實上，不把前後分離這件事考慮進去的話（畢竟這是前端 framework 最主要的目的），失去的不會比獲得的感受來的少多少，頂多接近打平，剩下的端看你的 M 體質點多高來去彌補。說實在的，當初把玩 Rust 語言被摧殘到躺地板時我覺得還比較爽一點。","text":"之前自學 React 時寫了一個簡單的線上簡歷，而我也確實靠他加分而拿到了工作，之後進去也是開始用 React 建立頁面，之後加上了 Redux；雖然這兩個總天數加起來大概就一個月，不敢說自己有摸清這些東西，不過還是就開發經驗來寫一些感想。 先講結論對 React 其實不討厭，還算是喜歡的；但若是要我向別人推荐的話，我會建議學 Vue.js 入門，熟了再考慮要不要碰 React。若是不排斥用其他語言轉換成 js 的話，Elm 看起來是個不錯的選擇，但 ES6 開始普及之後我對這方面的興趣不大，所以這個建議比較不負責任一點。 摸新東西當然都會面臨挫折、觀念轉變以及學習曲線的問題，但事實上，不把前後分離這件事考慮進去的話（畢竟這是前端 framework 最主要的目的），失去的不會比獲得的感受來的少多少，頂多接近打平，剩下的端看你的 M 體質點多高來去彌補。說實在的，當初把玩 Rust 語言被摧殘到躺地板時我覺得還比較爽一點。 簡介React 是以函數式編程為原則來做開發，函數式編程幾個簡單的重點如： 數值不可變：在一些比較嚴格規定的語言如 Haskell 的每個變數都是強制不可變的，而大部分的語言都是折衷分為可變與不可變。 一個函數只做一件事：這表示函數要單純，所以要把處理的事情分的很清楚，對不是從函數式語言入門的人來說，要分多清楚端看過往寫程式的經驗以及潔癖程度。 每次回傳都是一筆新的資料：基於數值不可變的特性。 一樣的參數 =&gt; 一樣的結果：這點也包括不該改變參數原本的值，比如 slice 與 splice 這兩個函數都能夠回傳一個陣列指定範圍的切片，但 splice 不屬於純函數。 12345678910111213141516let fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];// 純函數fruits.slice(1, 3); // [\"Orange\", \"Lemon\"]fruits.slice(1, 3); // [\"Orange\", \"Lemon\"]fruits.slice(1, 3); // [\"Orange\", \"Lemon\"]console.log(fruits); // ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']// 非純函數fruits.splice(1, 3); // [\"Orange\", \"Lemon\", \"Apple\"]console.log(fruits); // [\"Banana\", \"Mango\"]fruits.splice(1, 3); // [\"Mango\"]console.log(fruits); // [\"Banana\"]fruits.splice(1, 3); // [] 這會帶來什麼好處？ 耦合度低：每個函數都很單純，程式碼簡短（通常）。 容易測試：沒有副作用，傳入與傳出的結果是可預測的。 效率：有一個叫 Om 的項目，是以 ClojureScript 來寫 React 再轉成純 js，轉換後發現執行效率比用純 js 編寫高出了三倍，其中數值不可變是比較大的主因，促使 React 官方寫了 Immutable.js 以達成一樣的結果。 入門入門不算困難，只要知道兩個資料夾的分工、怎麼組合起來，你就入門了。 components存放網頁單一元素的地方，比如按鈕、表單、卡片等會重複使用到的東西，程式碼會儘量保持簡單乾淨。 123456789101112131415161718192021222324// Section.jsxclass Section extends React.Component &#123; render() &#123; return &lt;section className=\"section\"&gt;&#123;this.props.children&#125;&lt;/section&gt;; &#125;&#125;// Header.jsxclass Header extends React.Component &#123; render() &#123; return ( &lt;header&gt; &lt;h1&gt;&#123;this.props.title&#125;&lt;/h1&gt; &lt;/header&gt; ); &#125;&#125;// Description.jsxclass Description extends React.Component &#123; render() &#123; return &lt;p&gt;&#123;this.props.text&#125;&lt;/p&gt;; &#125;&#125; containers載入各個 component 組合出一個頁面、進行數據傳遞以及一些事件綁定的函式建立等等，簡單講就是骯髒事儘量先在這邊處理再傳遞到各個 component。 1234567891011// App.jsxclass App extends React.Component &#123; render() &#123; return ( &lt;Section&gt; &lt;Header title=\"Title\" /&gt; &lt;Description text=\"blablabla\" /&gt; &lt;/Section&gt; ); &#125;&#125; 最終會生成這段 html： 123456&lt;section class=\"section\"&gt; &lt;header&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;/header&gt; &lt;p&gt;blablabla&lt;/p&gt;&lt;/section&gt; 清楚明瞭是我剛入門時的第一個看法，尤其 jsx 的排法令人覺得賞心悅目，搭配 rscss 似乎會是個不錯的選擇。 入門之後？js 基於結構靈活（鬆散）的特性、越來越多的 libraries、frameworks 以及往網頁以外的領域發展的趨勢，使之成為一門易學難精的語言。而 React 本身對於以往的開發方式與概念是完全截然不同的，加上 ES6 語法、Webpack、BABEL、npm script 等等東西幾乎是要一起摸索，而在你摸索期間發現，網路上用上 ES7 當作範例的情況愈來愈多，對於初學在尋求幫助上，無異於徒增困擾。 隨著項目稍微變大、程式碼變多時，另一個問題就浮現了（至少我覺得困擾），一份 React 程式碼（尤其是 containers 資料夾底下的）通常是一份混雜著 js + jsx + html 語法的檔案，必要時還會加點 css，理想狀況是 jsx 將 html 包成一個個 component 再組合，使用起來比純 html 要來的賞心悅目，但 jsx 本身混雜的大括號一多，甚至不得已混了一點純 html 標籤進去時，那一段就會變成一個看起來非常雜亂的區塊，進而讓整份程式碼看起來更加凌亂。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// App.jsxclass App extends React.Component &#123; constructor() &#123; super(); this.state = &#123; hideAlert: true, hideModal: true &#125;; this.openModal = this.openModal.bind(this); this.closeModal = this.closeModal.bind(this); &#125; openModal() &#123; this.setState(&#123; hideModal: false &#125;); &#125; closeModal() &#123; this.setState(&#123; hideModal: true &#125;); &#125; render() &#123; const links = [&#123; href: '#', text: 'Link1' &#125;, &#123; href: '#', text: 'Link2' &#125;]; return ( &lt;Main&gt; &lt;Nav&gt; &#123;links.map((&#123; href, text &#125;, i) =&gt; &lt;Link key=&#123;i&#125; href=&#123;href&#125; text=&#123;text&#125; /&gt;; )&#125; &lt;/Nav&gt; &lt;Section&gt; &lt;Header title=\"Title\" /&gt; &lt;Content&gt; &lt;Description text=\"blablabla\" /&gt; &lt;Button primary onClick=&#123;this.openModal&#125; /&gt; &lt;/Content&gt; &lt;Alert hide=&#123;this.state.hideAlert&#125; text=\"You Idiot!!\" /&gt; &lt;/Section&gt; &lt;Modal hide=&#123;this.state.hideModal&#125; header=\"Modal Header\" description=\"blablabla\" onClose=&#123;this.closeModal&#125; /&gt; &lt;/Main&gt; ); &#125;&#125; 隨著鼓吹將 css 直接套進 jsx 的解決方案愈來愈多，無論你自己本身願不願意這樣寫，未來都將面臨看到愈來愈多將 css 硬塞進去的程式碼（事實上已經開始了），而你勢必得習慣他。 但這也不是沒有好處，以往載入如 Bootstrap 等的 framework 時，如果不考慮直接修改原始碼來改變樣式的話，很常需要另外寫 css 來覆蓋原本的設計，必要時還得補上 !important，如果用上如 Semantic UI 這種小元件很多又彼此有關聯的，那就有如一場災難。 jsx 裡的 css 以 JSON 格式儲存，如果想改變或新增部份的 Material-UI 裡的 css，只要寫進參數就可以直接替換。 當然，這所謂的「好處」是建立在你用的東西是這樣幹的時候。 Redux引入了 Redux 之後，以往用 jQuery 的事件處理變成資料流的方式進行，其實我還滿喜歡這個概念的，但實際運用時卻是有點令人煩躁。 觀念方面在一開始時，我還在摸索 React，所以對於 Flux/Redux 的技術只有看看文章而已，或許是我資質駑鈍，但這些文章跟圖說實在很難在我腦中建立關聯，在我摸索了幾個簡單的 Redux 官方範例好一陣子後，我才慢慢有個概念出來。 操作方面Redux 引入之後，在原本的兩個資料夾為基礎新增了 actions、reducers、store 三個資料夾，而新增一個按鈕事件時，流程是這樣的： 在 reducers 的 button.js 新增一個事件常數（比如 CLICK）進 switch case 裡。 在 actions 的 button.js 新增一個函數（比如 click()），負責傳遞這個常數以及資料過去給 reducer。 在 container 裡把 actions 裡的函數引進來，再傳給 Button component 做事件綁定。 Button component 接收到這個函數後，綁定在 DOM 事件上。 為了新增一個事件，一個沒有要幹什麼大事的事件，我得跑過四個資料夾才算完成！！ middlewares由於我是第一次使用 Redux，所以我決定不要任意引入額外的 middlewares，以了解 Redux 最原本的使用方式，但我還是去翻了翻一些網路範例常用的 middlewares，而這些 middlewares 常讓我有一個疑問（那感覺我也說不上來），他們到底是「解決方案」？還是「折衷方案」？抑或只是「虛幌一招」（看起來好像很厲害）？ 這恐怕只有在往後實際用上時才能體會了。 共通的問題重複的工作太多每建立一個 React 檔案，就得先補上以下的程式碼： 123456789import React, &#123; Component &#125; from 'react';class App extends Component &#123; render() &#123; // return jsx or html; &#125;&#125;export default App; 而 Redux 除了上面講的新增事件的困擾以外，如果是得多新增檔案，那也得補上跟其他檔案一樣的東西，縱使有 redux-actions 之類的 middleware 改善，但也僅僅是就那麼點改善，這到底是「解決方案」？還是「折衷方案」？ 學習與開發重點ES6Airbnb JavaScript Style Guide 可以當成一個不錯的 ES6 入門文件，之後再閱讀 ECMAScript 6 入门做更進一步的了解。 React 能用 css 解決的就用 css。 能用 Virtual DOM 解決的就不要用原生操作。 Say goodbye to jQuery. Airbnb React/JSX Style Guide 在 React 稍微懂一些後可以參考看看。 React 大部分的 plugins 程式碼都不多，使用前不妨看一下原始碼，或許你只需要擷取出一部份，不用再多載一個就能自己實現。 ES6 的 class 只做了半套，在有一定程度了解後，ES7 不妨給他用下去。 舉個簡單的例子，React 有 PropTypes 可以檢測傳進來的參數是否有錯誤，ES6 的寫法是這樣： 123456789101112class Modal extends React.Component &#123; render() &#123; // ...... &#125;&#125;Modal.propTypes = &#123; hide: React.PropTypes.bool.isRequired, header: React.PropTypes.string.isRequired, description: React.PropTypes.string.isRequired, onClose: React.PropTypes.func.isRequired&#125;; ES7： 123456789101112class Modal extends React.Component &#123; static propTypes = &#123; hide: React.PropTypes.bool.isRequired, header: React.PropTypes.string.isRequired, description: React.PropTypes.string.isRequired, onClose: React.PropTypes.func.isRequired &#125;; render() &#123; // ...... &#125;&#125; Redux 如果只是改變 component 自身狀態，不要考慮用。 跨 component 的事件處理如果數量不多，可以考慮不用。 第一次用建議不要用太多額外的 middlewares，先知道基本用法是怎樣，之後再去考慮這件事。 後記其他前端 framework 除了 ES6/ES7、Webpack 等等要學之外有沒有各自的狀況？我想是有的，但在討論學習曲線這件事時，我想不會有像 Twitter 上這樣的回應。 就像前面說的，js 是個易學難精的語言，配上 React 不一樣的觀念以及整個生態後，無異於更多麻煩。但目前已決定在 React 上暫且繼續做下去，對其它流行的前端框架目前興趣不大，也沒有切換的打算。 但我想我之後下個階段會研究 RxJS 與 Cycle.js 吧，其中 Cycle.js 與 Redux 都有從 Elm 語言尋求靈感，所以 Elm 或許也會成為一個考慮選項也說不定。 延伸閱讀 2016 年后 Web 开发趋势是什么 React 碎碎念: 艱困的新手之路 这段时间研究了下Redux，写写自己对它的感觉 線上課程 React.js Program：React 線上教學，其中 React.js Fundamentals 這個入門課程是免費的，推荐。 Getting Started with Redux：Redux 入門課程。 首圖來源React Redux Example","categories":[],"tags":[{"name":"react.js","slug":"react-js","permalink":"https://notes.knovour.ninja/tags/react-js/"},{"name":"redux","slug":"redux","permalink":"https://notes.knovour.ninja/tags/redux/"}]},{"title":"React.js 筆記 - Flux 的個人理解","slug":"react-flux-short-explain","date":"2016-05-01T18:01:07.000Z","updated":"2017-05-13T11:04:54.524Z","comments":true,"path":"2016/05/02/react-flux-short-explain/","link":"","permalink":"https://notes.knovour.ninja/2016/05/02/react-flux-short-explain/","excerpt":"React.js 的 Flux 的部份我看了好久還是不太能理解他的意思，這幾天總算理出點頭緒（雖然不知道對不對…），在這邊做一點紀錄。 簡單介紹Flux 算是一套前端的處理流程，一般的講法就是前端版的 MVC，主要分四大部份： Action: 事件觸發或是跟後端溝通後，發送資料給 Dispatcher。 Dispatcher: 根據資料內容，分派至對應的函式做處理（通常是參照資料裡面的一個 type 屬性）。 Store: 儲存負責處理資料的函式，向 Dispatcher 註冊後，再由 Dispatcher 負責分發。 View: 接收處理後的結果並更新頁面。 這邊所指的資料在 React.js 裡叫作 state，當 state 更新之後 View 就會對頁面做相對應的更新。 用 jQuery 當範例以點擊按鈕就新增一張卡片為例，一開始用 jQuery 寫時，大概會像下面這樣子： 1234567$('#addCard').click(function() &#123; //- 新增數據 /* do something */ //- 生成 html 並放進網頁裡 /* do something */&#125;);","text":"React.js 的 Flux 的部份我看了好久還是不太能理解他的意思，這幾天總算理出點頭緒（雖然不知道對不對…），在這邊做一點紀錄。 簡單介紹Flux 算是一套前端的處理流程，一般的講法就是前端版的 MVC，主要分四大部份： Action: 事件觸發或是跟後端溝通後，發送資料給 Dispatcher。 Dispatcher: 根據資料內容，分派至對應的函式做處理（通常是參照資料裡面的一個 type 屬性）。 Store: 儲存負責處理資料的函式，向 Dispatcher 註冊後，再由 Dispatcher 負責分發。 View: 接收處理後的結果並更新頁面。 這邊所指的資料在 React.js 裡叫作 state，當 state 更新之後 View 就會對頁面做相對應的更新。 用 jQuery 當範例以點擊按鈕就新增一張卡片為例，一開始用 jQuery 寫時，大概會像下面這樣子： 1234567$('#addCard').click(function() &#123; //- 新增數據 /* do something */ //- 生成 html 並放進網頁裡 /* do something */&#125;); 隨著按鈕或其他元件的增加，要新增的事件也會變多，例如再增加一個刪除卡片： 123456789101112131415$('#addCard').click(function() &#123; //- 新增數據 /* do something */ //- 生成 html 並放進網頁裡 /* do something */&#125;);$('#delCard').click(function() &#123; //- 處理要刪除的數據 /* do something */ //- 刪除卡片的 html 部份 /* do something */&#125;); 開發的時間久了之後，你可能會開始想要把 function 拆出來，並給予有意義的名字，例如： 12345678910111213141516171819202122232425262728$('#addCard').click(addCard);$('#delCard').click(delCard);/* 或是 */$('#addCard').click(function() &#123; addCard(/* 額外的參數 */);&#125;);$('#delCard').click(function() &#123; delCard(/* 額外的參數 */);&#125;);function addCard() &#123; //- 新增數據 /* do something */ //- 生成 html 並放進網頁裡 /* do something */&#125;function delCard() &#123; //- 處理要刪除的數據 /* do something */ //- 刪除卡片的 html 部份 /* do something */&#125; 本著 function 只處理一件事的精神，我們把更新頁面（View）的部份拆回來： 1234567891011121314151617181920212223$('#addCard').click(function() &#123; const data = addCard(/* 額外的參數 */); //- 生成 html 並放進網頁裡 /* do something */&#125;);$('#delCard').click(function() &#123; const data = delCard(/* 額外的參數 */); //- 刪除卡片的 html 部份 /* do something */&#125;);function addCard() &#123; //- 新增數據 /* do something */&#125;function delCard() &#123; //- 處理要刪除的數據 /* do something */&#125; 之後可能會想統整起來，改由一個 handler 之類的負責分派： 1234567891011121314151617181920212223242526272829303132$('#addCard').click(function() &#123; const data = CardHandler(&#123; type: 'ADD_CARD', /* 額外的參數 */ &#125;); //- 生成 html 並放進網頁裡 /* do something */&#125;);$('#delCard').click(function() &#123; const data = CardHandler(&#123; type: 'DEL_CARD', /* 額外的參數 */ &#125;); //- 刪除卡片的 html 部份 /* do something */&#125;);function CardHandler(action) &#123; switch(action.type) &#123; case 'ADD_CARD': //- 新增數據 /* do something */ break; case 'DEL_CARD': //- 處理要刪除的數據 /* do something */ break; &#125;&#125; 那整個 Flux 的流程，用很籠統的圖解大概是這樣： Store 就是儲存事件所對應的工作，Dispatcher 負責分發；而 Redux 在此之上額外拆出了 Reducer，但基本流程不變。","categories":[],"tags":[{"name":"react.js","slug":"react-js","permalink":"https://notes.knovour.ninja/tags/react-js/"},{"name":"redux","slug":"redux","permalink":"https://notes.knovour.ninja/tags/redux/"},{"name":"flux","slug":"flux","permalink":"https://notes.knovour.ninja/tags/flux/"}]},{"title":"記憶中看過最不尊重設計的一件事","slug":"one-thing-about-disrespect-design-in-my-memory","date":"2016-04-14T12:41:48.000Z","updated":"2017-05-13T11:04:23.831Z","comments":true,"path":"2016/04/14/one-thing-about-disrespect-design-in-my-memory/","link":"","permalink":"https://notes.knovour.ninja/2016/04/14/one-thing-about-disrespect-design-in-my-memory/","excerpt":"","text":"這件事其實很久了，只是最近又想到它，所以乾脆紀錄下來好了。 思源黑體，一套完整的中文字體，可以在網頁上完整顯示，不會因為找不到字而出現豆腐框為主要目標，現在應該很多人都知道這個字體了；Google 那邊則另外命名叫 Noto Sans，不過重點不在這，這邊只是要紀錄一下思源黑體剛發佈時發生的事。 當時在 Adobe Typekit Blog 上，官方發文介紹了這個字體的誕生，談了一下設計的人員，以及講解一些中文字在使用漢字的國家之間寫法的差異。 但有個傢伙卻開始在留言中大談古字的真善美，談台灣教育部的不是，義正辭嚴的要求遵循「正統」繁體中文的字體寫法，鬧了一輪後還去辦了個 GitHub 帳號跑去發 issue 再來一次，硬要這群國外設計團隊也該當個考古學者；在這串上面大放厥詞拍拍屁股後，直到現在再也沒有在任何 issue 裡出現過。 網路留言看久了之後感覺，那種習慣把自己叫「在下」的人，要馬只是單純宅了點，要馬就是個白目。","categories":[],"tags":[{"name":"雜談","slug":"雜談","permalink":"https://notes.knovour.ninja/tags/雜談/"}]},{"title":"D3 + p5.js 筆記 - Bar Chart","slug":"d3-p5-js-notes-bar-chart","date":"2016-03-29T15:36:17.000Z","updated":"2017-05-13T11:03:43.342Z","comments":true,"path":"2016/03/29/d3-p5-js-notes-bar-chart/","link":"","permalink":"https://notes.knovour.ninja/2016/03/29/d3-p5-js-notes-bar-chart/","excerpt":"程式碼 範例來源 程式碼說明這次範例來源有 hover 的顏色變化，為了省略寫作標判定的部份，我另外載入了 p5.play.js。","text":"程式碼 範例來源 程式碼說明這次範例來源有 hover 的顏色變化，為了省略寫作標判定的部份，我另外載入了 p5.play.js。 大部分的區塊應該不用特別講了，大概提一下 p5.play.js 的一點坑就好。 createSprite 的座標指的是每個 bar 的中心點，向外畫出矩形，所以不會像一般畫長方形一樣，座標在左上角，若不額外調整位置會跑掉。然而，這種畫法是不是最終定案不清楚，畢竟 p5.play.js 還不是正式版。 題外話用 canvas 畫圖其中一個麻煩的地方大概就是游標判定了，p5.play.js 的游標判定功能不算強大，只有支援圓跟矩形，圖片則是有另外的判定方式（游標底下是不是透明背景之類），跟其他遊戲引擎類的差不多。 像百度的 ECharts 的範例互動多半也是用比較折衷的做法。 不過之前看到了 Paper.js 這個東西，在游標測試的範例裡看起來運作得很完美，改天來試試看。","categories":[],"tags":[]},{"title":"Sails.js 的一些問題及現況","slug":"problems-about-sails-js","date":"2016-03-22T16:00:06.000Z","updated":"2017-05-13T11:04:44.461Z","comments":true,"path":"2016/03/23/problems-about-sails-js/","link":"","permalink":"https://notes.knovour.ninja/2016/03/23/problems-about-sails-js/","excerpt":"本來標題想寫「Sails.js 算不算死了」，不過這樣似乎太過分了，這篇主要是講講之前用它來開發的感受。 TL;DR - 不負責任懶人包Sails.js 主要維護者 mikermcneil 與其中一位成員 tjwebb 有「理念上的問題」，導致開發停滯了超過半年之久，之後後者離開另外建立了 Trails.js，而 Sails.js 在今年繼續維護。","text":"本來標題想寫「Sails.js 算不算死了」，不過這樣似乎太過分了，這篇主要是講講之前用它來開發的感受。 TL;DR - 不負責任懶人包Sails.js 主要維護者 mikermcneil 與其中一位成員 tjwebb 有「理念上的問題」，導致開發停滯了超過半年之久，之後後者離開另外建立了 Trails.js，而 Sails.js 在今年繼續維護。 長篇抱怨文去年的時候，Sails.js 的版本停在 0.12.0-rcX（忘記哪個號碼）超過半年之久；在這段期間，issue 上面的回應也零零落落的，而我那時才知道，開發團隊其實有養一隻 GitHub robot，太久沒回應的 issue 會強制關掉，這到是讓我感到不滿。 當初 Node.js 入門時是從 Express.js 開始的，也很習慣從這樣一個基礎的 framework 再自己安裝其他 plugin 兜成自己需要的東西，但每建一個新的專案就要重新兜一次，久了其實也挺煩的，當時也不知道 Yeoman 這種工具。 後來試了 Kraken.js 以及 Sails.js 這兩個比較屬於包山包海的 framework，而且都是以 Express.js 為基底再包上一層，在使用一段時間後卻覺得這反而讓我更加麻煩，表面上似乎是幫你解決了一些雜事，反之要面對的卻是一長串看似方便其實很亂的 config 參數。 當時用了 Kraken 1.x 的版本，就像是包上了一層薄薄的蝦殼，薄到讓我覺得多包這一層沒什麼太大的意義，原本 middleware 的載入方式改成透過 config 反而變得很難用，加上當時在折騰 Socket.IO，而 Kraken.js 並沒有往這方面做進一步整合，導致不論是在 Express.js 或是 Kraken.js 裡加上 Socket.IO 的方式是差不多的，但後者還得多繞一點彎路，本末倒置。 而 Sails.js 有將之另外整合，並打包成了 sails.io.js，相比之下方便不少，所以最後採用它來寫了幾個專案，但一段時間後也開始有了一些怨氣，一個是預設作為自動化排程的 Grunt 非常難用，相關設定又臭又長而且不盡相同，我曾為了某個 plugin 設定搞不定而折騰很長一段時間，最後卻是參考其他不相關的 plugin 的設定方式照著改過去才成功。 另一方面是作為核心的 Express.js 的版本問題，Kraken.js 因為有 PayPal 罩著，所以遷移到 Express 4.x 的速度很快，但 Sails.js 就不是這麼一回事了，官方一直停在 3.x 版，開發又停滯了一段時間，使得以 Express.js 為主的 plugin 也得限制版本號才能使用，本來這不是什麼大問題，因為當時連 Node.js 的更新也很緩慢，也是在 0.12 上卡了很長一段時間，後來在用 Sails.js 寫最後一個專案時，Node.js 突然直接跳到了 4 版，不久 5 版也跟著推出了。這下感受就大不同了（還是可以動，主要是奇蒙子問題），那時也才開始在意 Sails.js 停滯很長一段時間這件事；在這段時間裡，也造成一些 issue 因為沒有後續回應的關係而被官方的 bot 自動關掉，最後決定趁著專案的開發時間還不算久的情況下，直接改用 Koa.js 重新開發，不再碰 Sails.js。 在遷移一陣子之後，發現了 Trails.js 的存在，這是 Sails.js 的其中一個成員離開之後建立的專案，看裡面的專案數量，似乎是以 Koa.js、Express.js、Hapi.js 等各個基礎 framework 為底，再分別客製打包而成，在安裝時就可以選自己順手的為底來往上建立，選擇上比較靈活，但官方維護的心力應該也多了不少，目前還在 1.0 alpha，能不能取代 Sails.js 還得再觀察。 相關網址 Ending Sails.js Support. Migrating sails-permissions to Trails（裡面有列一些相關討論的 issue 連結，包含雙方各自的說法） 以前 Blog 寫的 Kraken.js 筆記（不過現在都 2.0 了，應該比較沒參考價值了） Trails.js 介紹影片 自肥區我把在使用 Koa.js 這段期間用到的 plugins 以自己覺得合適的架構打包，並用 Yeoman 來做自動化安裝，不過目前只有做將整個專案架構複製到自己的資料夾裡這件事而已，更多客製化的方式還得研究研究，另外之後會先把 plugins 刪掉一大部分，並將 Gulp.js 改成單純的用 npm script 來自動化管理專案，等這些基本問題弄好後，再把其他 plugins 加回去。 專案網址","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://notes.knovour.ninja/tags/node-js/"},{"name":"sails.js","slug":"sails-js","permalink":"https://notes.knovour.ninja/tags/sails-js/"}]},{"title":"D3 + p5.js 筆記 - 自訂 preload 的 Ajax","slug":"d3-p5-js-notes-custom-ajax-preload","date":"2016-03-22T08:17:20.000Z","updated":"2016-03-22T10:15:00.049Z","comments":true,"path":"2016/03/22/d3-p5-js-notes-custom-ajax-preload/","link":"","permalink":"https://notes.knovour.ninja/2016/03/22/d3-p5-js-notes-custom-ajax-preload/","excerpt":"","text":"p5.js 已經內建數種檔案請求的方式，這邊紀錄一下自己建立 ajax 請求註冊到 preload() 的方式（以 D3 為例）。 這邊要注意的是，在第 10 行的部份，請求後的資料不能直接指定給預先宣告的變數，否則 setup() 取資料時會是 undefined，或者可以這樣宣告： 12345'use strict'// load functionlet tmp = &#123; list: [] &#125;;// --- 在取得資料後直接將資料指定給 tmp.list，在 setup() 裡直接以 data.list 的方式取值即可，而範例裡的 return 跟 callback 都是必要的，省略任何一樣都會出現 undefined。 不用 new 的方式可以到這裡檢視。","categories":[],"tags":[{"name":"D3","slug":"D3","permalink":"https://notes.knovour.ninja/tags/D3/"},{"name":"p5.js","slug":"p5-js","permalink":"https://notes.knovour.ninja/tags/p5-js/"}]},{"title":"D3 + p5.js 筆記 - Area Chart","slug":"d3-p5-js-notes-area-chart","date":"2016-03-03T14:44:07.000Z","updated":"2017-05-13T11:03:31.179Z","comments":true,"path":"2016/03/03/d3-p5-js-notes-area-chart/","link":"","permalink":"https://notes.knovour.ninja/2016/03/03/d3-p5-js-notes-area-chart/","excerpt":"程式碼 範例來源 程式碼說明以下主要說明部份的坑以及重點，請配合 GitHub 的 js 程式碼服用。","text":"程式碼 範例來源 程式碼說明以下主要說明部份的坑以及重點，請配合 GitHub 的 js 程式碼服用。 preloadctx.loadTable 是非同步處理，最普通的作法就是指定給宣告的變數 1dataset = ctx.loadTable('area.tsv', 'tsv', 'header', callback) 但 preload 請求的資料，在 setup 函式裡才可以使用，如果直接在 preload 裡 console 出來是沒有東西的，但你可以宣告 callback function 來對資料預先處理。 不得不說，p5.js 的 loadTable 幫你整理資料這件事實在非常多餘，幫你把資料整理好了，但你卻沒法直接取出完整的 json 陣列資料。 而官方提供的 API 中，最接近的 getObject 取出來的樣子是： 12345&#123; '0': data1, '1': data2, '2': ...&#125; WTF setup主要就是在這邊讓 D3 計算縮放後的刻度、座標，由於 draw 的函式預設會刷新畫布，所以能夠事先計算的部份都盡量放在 setup 裡。 123456789101112xScale = d3.time.scale() .domain(d3.extent(dataset, d =&gt; d.date)) .range([ chartX, chartWidth + chartX ]);xTickFmt = xScale.tickFormat(date =&gt; date.getFullYear());xLabels = xScale.ticks(d3.time.year);yScale = d3.scale.linear() .domain([ 0, d3.max(dataset, (&#123; close &#125;) =&gt; close) ]) .range([ chartHeight + chartY, chartY ]);yLabels = yScale.ticks(10); domain、range，簡單來講就是從資料以及指定的畫布大小來決定畫布上的座標，省去寫縮放程式碼的麻煩。 X 軸是以時間為刻度，用 D3 的 ticks 設定為以年份劃分刻度，Y 軸則設定為分割成 10 個座標。ticks 最後會產生一串陣列，裡面存放刻度的標籤名稱，用 yScale(data) 可以取得該筆資料在 Y 軸的位置。 drawp5 預設會重複畫 draw 裡的內容，可以在 setup 補上 noLoop 來關掉自動重繪，否則也要在 draw 的開頭使用 clean 來清掉畫布，否則畫布上的元素會重複疊加上去。另外畫布的背景預設為透明，故需先畫上指定顏色的背景，否則存成圖檔時會是透明背景。 這邊注意的一點是，除了 stroke、fill 等等會影響畫筆（ctx）行為之外，有些則是會影響整個畫布的，比如 rotate 會把要畫的圖層整個旋轉，結尾要使用 resetMatrix 調回原狀，或是用 push 與 pop 來暫存原本的狀態。 比如前面設定 fill 的顏色，但是在 push 與 pop 之間使用 noFill 時，當 pop 出來後畫筆依舊是 fill 的狀態。","categories":[],"tags":[{"name":"D3","slug":"D3","permalink":"https://notes.knovour.ninja/tags/D3/"},{"name":"p5.js","slug":"p5-js","permalink":"https://notes.knovour.ninja/tags/p5-js/"}]},{"title":"D3 + p5.js 筆記 - 介紹 p5","slug":"d3-p5-js-notes-introduce-p5","date":"2016-03-02T16:43:10.000Z","updated":"2016-03-21T13:21:27.885Z","comments":true,"path":"2016/03/03/d3-p5-js-notes-introduce-p5/","link":"","permalink":"https://notes.knovour.ninja/2016/03/03/d3-p5-js-notes-introduce-p5/","excerpt":"先來大致介紹一下 p5.js。 這是 Processing 團隊移植的 web 版本，除了 p5 之外還有一個是由 jQuery 作者自己實現，叫 Processingjs 的函式庫，可別搞混了。 為什麼選擇 p5？以前大學時有教授教過 Processing 算是因素之一，入門上不算太難。 在圖片繪製上，p5 也簡化了一些步驟，比如畫線的時候，canvas 的畫法是 12canvas.moveTo(x, y);canvas.lineTo(x2, y2); 而 p5 只要一個 line 就可以解決。稍微試過 Pixi.js 與 EaselJS，這兩個基本上跟 canvas 原本的畫法差不了多少，畢竟定位是遊戲引擎，p5 是繪圖函式庫。","text":"先來大致介紹一下 p5.js。 這是 Processing 團隊移植的 web 版本，除了 p5 之外還有一個是由 jQuery 作者自己實現，叫 Processingjs 的函式庫，可別搞混了。 為什麼選擇 p5？以前大學時有教授教過 Processing 算是因素之一，入門上不算太難。 在圖片繪製上，p5 也簡化了一些步驟，比如畫線的時候，canvas 的畫法是 12canvas.moveTo(x, y);canvas.lineTo(x2, y2); 而 p5 只要一個 line 就可以解決。稍微試過 Pixi.js 與 EaselJS，這兩個基本上跟 canvas 原本的畫法差不了多少，畢竟定位是遊戲引擎，p5 是繪圖函式庫。 canvas 1px 直線問題canvas 有一個渲染上的問題，很多剛碰的人大概都會遇到，在畫 1px（或其他奇數）寬的線時，在螢幕上顯示卻有 2px 寬。 簡單圖解類似這樣： 當在座標上畫線時，canvas 並不會在該座標的 右邊或左邊畫線，而是會以座標為準，向兩邊各佔用一半的 px，在這邊就各佔用了 0.5px。而 canvas 的渲染機制就會把兩邊剩下的 0.5 補上顏色，類似防鋸齒那樣，就造成畫 1px 卻有 2px 寬的情形發生。 解決方式就是向前或向後退 0.5 px，而 p5 會幫你搞定這件事，但由於 [D3] 在幫你計算刻度座標時，數值不會那麼漂亮，所以還是會有漏網之魚發生，至少 XY 軸是正常顯示的。 p5 的基本構造基本上要先建立以下三個函數： 1234567891011function preload() &#123; // 載入 csv, tsv 等檔案&#125;function setup() &#123; // 初始化資料、建立 canvas 等&#125;function draw() &#123; // 繪製圖形&#125; 其中 preload 可有可無，端看須不需要額外載入資料檔案，而絕大部分繪製的相關函數必須要在 p5 指定的函數裡呼叫，否則不會有作用。當然也有其他的函數是獨立的（比如事件偵測），但絕大部分的還是得照著規則進行。 p5 的問題全域變數p5 的函數都是全域變數，而一個網頁照一般的寫法也只會寫一個 preload、setup、draw 等函數，當需要數個 canvas 時（畫圖表時有多個畫布很正常吧），創建 canvas 的程式碼全都要擠在同一個 setup 裡（無法用匿名函數分開包裝），在繪製時又會全部擠在一起一次，因而造成很大的麻煩。 編輯器正因為 p5 函式都是全域變數不須宣告，所以當你在寫程式碼時，你的編輯器會出現一堆下劃線，提醒你變數未宣告之類的錯誤。 解決方式用 new 宣告一個。 123456789new p5(ctx =&gt; &#123; ctx.setup = () =&gt; &#123; &#125; ctx.draw = () =&gt; &#123; &#125;&#125;); 在這裡面，不管要使用什麼函數，都要用 ctx.[函數名稱] 才可使用，但也避免了瀏覽器與編輯器的問題。 其他參考 sketchpad: 網路上有一個 sketchpad，上面列了一些用 p5 繪製的圖片與程式碼，可以大致了解一下怎麼寫出來的。 p5.js － 初學者的資料視覺化函式庫 Processing.js 的一些介紹及分享","categories":[],"tags":[{"name":"D3","slug":"D3","permalink":"https://notes.knovour.ninja/tags/D3/"},{"name":"p5.js","slug":"p5-js","permalink":"https://notes.knovour.ninja/tags/p5-js/"}]},{"title":"D3 + p5.js 筆記 - 前言","slug":"d3-p5-js-notes","date":"2016-03-01T01:20:14.000Z","updated":"2016-03-02T19:04:02.177Z","comments":true,"path":"2016/03/01/d3-p5-js-notes/","link":"","permalink":"https://notes.knovour.ninja/2016/03/01/d3-p5-js-notes/","excerpt":"","text":"這陣子看了點 D3，並找了官方 wiki 的範例來試試，不過不是用 SVG，而是用 canvas 來畫。 之前要寫的網站要生成簡易的圖表，但因為沒學過 D3 的經驗（當時也來不及），所以找了現成的 Chart.js 來用，除了這套之外，之後也在 feedly 看了不少圖表生成的套件介紹，蠻多都是用 canvas 的。不過這倒也不是什麼選擇 canvas 的原因。 單純犯賤罷了… 然而，D3 對 canvas 的支援不好，不過這也不是很意外。問題在於要怎麼用 D3 把處理後的資料給 canvas 畫，根據這裡的介紹，第三種方式算是我在網路上最常看見的，基本上就是處理資料並創建虛假的元素，假裝自己在操作 SVG，然後再把這些假元素吐出來再用 canvas 的方式畫出來，怎麼看都覺得…蠻蠢的。所以我比較偏好第二種方式，讓 D3 負責處理資料、生成刻度等等，再用 p5.js 直接畫上去。 總之，之後會加減從 D3 官方的範例裡面先挑簡單的例子來練習，也會原始碼放到 GitHub 上。","categories":[],"tags":[{"name":"D3","slug":"D3","permalink":"https://notes.knovour.ninja/tags/D3/"},{"name":"p5.js","slug":"p5-js","permalink":"https://notes.knovour.ninja/tags/p5-js/"}]},{"title":"Sequelize 踩坑筆記","slug":"sequelize-notes","date":"2016-01-12T15:44:32.000Z","updated":"2016-01-20T16:26:34.220Z","comments":true,"path":"2016/01/12/sequelize-notes/","link":"","permalink":"https://notes.knovour.ninja/2016/01/12/sequelize-notes/","excerpt":"範例以這裡為準（以下會換成 ES6 寫法），Koa 用法亦同 異步程式碼寫法以 co 這套件來簡化 Promise 寫法 內建參數的位置","text":"範例以這裡為準（以下會換成 ES6 寫法），Koa 用法亦同 異步程式碼寫法以 co 這套件來簡化 Promise 寫法 內建參數的位置 基本用法我們在 getFullName 裡加上以下這段 1234return co(function*() &#123; const user = yield User.findOne(); return `$&#123;user.firstName&#125; $&#123;user.lastName&#125;`;&#125;); getterMethods 裡可以加入一個 fullName 的 function 12345getterMethods: &#123; fullName() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`; &#125;&#125; 這樣 getFullName 裡就可以直接寫 user.fullName 獲取全名了。 在外部使用時可以直接寫 123456const Models = require('/path/to/models'); // 注意範例裡的 index.js 內容co(function*() &#123; const fullName = yield Models.User.getFullName(); console.log(fullName);&#125;).catch(console.error); 使用其他 table假如我在 User 裡需要用到其他 table（假設叫 Family），我就可以寫 sequelize.models.Family 來呼叫。 建立關聯（associate）假設有個 table 叫 Pet，裡面有個 key 叫 owner，用以紀錄 User 的 id。 兩邊的關聯性程式如下 1234567// 寫在各自的 associate function 裡// PetPet.belongsTo(models.User, &#123; foreignKey: 'owner' &#125;);// User（owner 即為 Pet 裡的 key）User.hasMany(models.Pet, &#123; foreignKey: 'owner' &#125;); include在查找的 json 中用 include 時，hasMany 與 hasOne 出來的 table 名稱會有單複數差異 123456789101112131415// hasMany&#123; firstName: 'XXXX', Pets: [&#123; ... &#125;]&#125;// hasOne&#123; firstName: 'XXXX', Pet: &#123; ... &#125;&#125; group要將 include 的資料進行 group 或 order 時，需要連帶寫上 table 名稱，例：Pets.id。","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://notes.knovour.ninja/tags/node-js/"}]},{"title":"放棄在 OpenShift 上管理部落格","slug":"change-blog-from-openshift-to-github","date":"2016-01-11T15:40:12.000Z","updated":"2016-01-11T16:40:27.855Z","comments":true,"path":"2016/01/11/change-blog-from-openshift-to-github/","link":"","permalink":"https://notes.knovour.ninja/2016/01/11/change-blog-from-openshift-to-github/","excerpt":"去年決定將 Blog 從 Logdown 換成自架 Ghost 後，就想找一個線上空間來管理。但 Linode 或 Digital Ocean 要從頭來覺得麻煩，而 Heroku 不知道為何怎樣就是看不懂，後來看到 OpenShift 設定似乎挺簡單，於是就辦來試試看。 無奈 OpenShift 根本 Bug 滿天飛，社群的 Ghost 架設速成 script 根本不能用就算了，連從官方的 Node.js 重頭架也常設定跑失敗，跑到最後居然是鎖我帳號？？更別說我在試用時三不五時被登出，不然就是怎麼按 Application 都沒顯示東西，也不知道怎麼回到我剛剛的設定頁面。","text":"去年決定將 Blog 從 Logdown 換成自架 Ghost 後，就想找一個線上空間來管理。但 Linode 或 Digital Ocean 要從頭來覺得麻煩，而 Heroku 不知道為何怎樣就是看不懂，後來看到 OpenShift 設定似乎挺簡單，於是就辦來試試看。 無奈 OpenShift 根本 Bug 滿天飛，社群的 Ghost 架設速成 script 根本不能用就算了，連從官方的 Node.js 重頭架也常設定跑失敗，跑到最後居然是鎖我帳號？？更別說我在試用時三不五時被登出，不然就是怎麼按 Application 都沒顯示東西，也不知道怎麼回到我剛剛的設定頁面。後來過了幾個月回去看又好了（Heroku 這段期間我還是看不懂），但 Ghost 速成 script 還是不能用，至少官方 Node 是可行的，於是就把 Ghost 給弄起來了（中間在 Build 時還是爆掉幾次）。之後要把 Ghost 給升級時，說要額外加 Gear（就是要收錢的意思），我就給他加了，反正一個月只有收大概幾塊錢。 最近幾個月，Let’s Encrypt 開放後熱了起來，想說看能不能在自己的 Blog 弄上去，然後找到了這篇文章，做到替換 index.js 來進行認證的階段怎樣就是失敗，後來又開了社群的 script 來試，結果居然可以跑了，而且替換 index.js 再認證的部份是 OK 的，雖然後面的步驟我沒做，但我也不想弄了。 這兩天把上面幾篇比較重要的文章搬到 Github，改用 Hexo 管理後，想把 OpenShift 上的砍掉重架當備份，無奈這次 script 又不能跑了，既然這樣也不強求了，隨他去吧，砍了帳號，別再收我錢就好。 現在 domain 改用 CloudFlare 管理，免費方案也有 SSL，這樣搞還比較省事。","categories":[],"tags":[{"name":"openshift","slug":"openshift","permalink":"https://notes.knovour.ninja/tags/openshift/"},{"name":"ghost","slug":"ghost","permalink":"https://notes.knovour.ninja/tags/ghost/"}]},{"title":"在 Linux 上執行 Path of Exile (PoE)","slug":"path-of-exile-on-linux","date":"2015-09-16T13:26:00.000Z","updated":"2017-11-07T12:25:48.769Z","comments":true,"path":"2015/09/16/path-of-exile-on-linux/","link":"","permalink":"https://notes.knovour.ninja/2015/09/16/path-of-exile-on-linux/","excerpt":"之前在 Wine 上跑過一陣子 PoE，但經過幾次更新後，loading 畫面除了狂閃外基本上就是完全進不去的狀態，然而當時也是有點膩了，所以也懶得折騰（基本上都是在講把 Wine 降級或是裝 PlayOnLinux，不過不想這樣搞）。 現在 2.0 出了，「據說」修好了錯位，也偶然發現有一篇比較不那麼麻煩的設定文章，試一試還真的成功了，在這邊紀錄一下。","text":"之前在 Wine 上跑過一陣子 PoE，但經過幾次更新後，loading 畫面除了狂閃外基本上就是完全進不去的狀態，然而當時也是有點膩了，所以也懶得折騰（基本上都是在講把 Wine 降級或是裝 PlayOnLinux，不過不想這樣搞）。 現在 2.0 出了，「據說」修好了錯位，也偶然發現有一篇比較不那麼麻煩的設定文章，試一試還真的成功了，在這邊紀錄一下。註：文章裡似乎是把 PoE 另外裝其他地方，再外帶參數啟動（我的理解啦），但我沒有用 Wine 模擬其他東西的需要，所以就把覺得可以跳過的部份跳過，下面的紀錄基本上就是個精簡後的設定步驟。 環境 Manjaro Linux KDE Plasma 5 NVIDIA 顯卡 執行 winecfg 選定 windows 版本（原文是 8 不過選 10 也沒差）。 將 openal32 加進函式庫裡。 勾選虛擬桌面，解析度自己根據需求調整。 安裝 windows 相關套件執行 winetricks directx9 vcrun2010 riched20 usp10 安裝遊戲執行 PoE 安裝檔，之後再開啟下載主程式，這部份不會有問題，但主程式裝完後先關掉不要按 Launch，不然 wine 會當掉。 執行 wine regedit安裝期間可以先處理這部份（在 regedit 裡移到對應的路徑） HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes：新增一個字串值叫 Fontin SmallCaps，數值為 Fontin。 HKEY_CURRENT_USER\\Software\\Wine\\Direct3D：若沒有 Direct3D 的資料夾則自行新增一個。在底下新增以下資料： OffscreenRenderingMode：字串值為 backbuffer。 VideoMemorySize：這是你的顯卡記憶體大小，以 MB 計，我的是 2048。 UseGLSL：NVIDIA 顯卡限定，值為 disabled，若執行時覺得有問題可以把這個值移除看看。 設定 PoE到 ~/文件/My Games/Path of Exile/（不同發行版位置可能不大一樣），開啟 production_Config.ini，在 [DISPLAY] 底下新增或替換以下設定： fullscreen=true borderless_windowed_fullscreen=false resolution_height=虛擬桌面高度 resolution_width=虛擬桌面寬度 結束等 PoE 主程式載完就可以啟動了。 感想 基本上不會像以前那樣 FPS 掉很重了，但偶爾會破圖。 地圖亮度偏暗，地穴根本是黑的，使用冰系或雷系技能擊中或發動瞬間會照亮地圖（火焰反而沒法照亮…），招喚 Golem（2.0 新技能）可以永久照亮。 音效要在設定裡選擇 Generic Software on out 開頭的才有聲音。 只有 Act4 沒錯位就算了，Act123 + Map 的錯位感覺更嚴重了是怎樣，新增的 Map 也是一樣慘。 參考來源Path of Exile on Linux","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://notes.knovour.ninja/tags/Linux/"},{"name":"wine","slug":"wine","permalink":"https://notes.knovour.ninja/tags/wine/"},{"name":"game","slug":"game","permalink":"https://notes.knovour.ninja/tags/game/"}]},{"title":"用 PM2 部署 node server","slug":"deploy-node-js-by-pm2","date":"2015-08-12T18:38:00.000Z","updated":"2016-01-11T15:48:49.372Z","comments":true,"path":"2015/08/13/deploy-node-js-by-pm2/","link":"","permalink":"https://notes.knovour.ninja/2015/08/13/deploy-node-js-by-pm2/","excerpt":"前置作業首先先設定完這篇文的前置作業。 部署與開發用的機器都要安裝 PM2：sudo npm i pm2 -g 部署設定於專案資料夾底下執行 pm2 ecosystem 生成 ecosystem.json5，修改副檔名為 json 檔以便顯示語法 hightlight。 將裡面的內容做修改 注意最後一句裡 pm2 startOrRestart ecosystem.json 的副檔名是否相同。","text":"前置作業首先先設定完這篇文的前置作業。 部署與開發用的機器都要安裝 PM2：sudo npm i pm2 -g 部署設定於專案資料夾底下執行 pm2 ecosystem 生成 ecosystem.json5，修改副檔名為 json 檔以便顯示語法 hightlight。 將裡面的內容做修改 注意最後一句裡 pm2 startOrRestart ecosystem.json 的副檔名是否相同。 開始部署第一次部署時先執行 setup pm2 deploy ecosystem.json production setup 成功後就可以正式部署了 pm2 deploy ecosystem.json production 之後專案更新時只要執行第二句即可。 一切順利的話 PM2 就會在 server 端開始執行了。 額外指令開機啟動：pm2 startup -u DEPLOY_SERVER_USER_ACCOUNT 不設 -u（user）的話，在開機時預設就會以 root 權限執行。 其他指令或設定請至 PM2 檢視說明文件 參考來源 PM2 PM2 Advance Readme 使用 PM2 Deploy 部署基于 Git 版本管理的网站应用 PM2 GitBook Deploying Node.js Applications with PM2","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://notes.knovour.ninja/tags/node-js/"},{"name":"deploy","slug":"deploy","permalink":"https://notes.knovour.ninja/tags/deploy/"}]},{"title":"用 Shipit 部署 node server","slug":"deploy-node-js-by-shipit","date":"2015-07-17T15:42:00.000Z","updated":"2017-05-17T19:42:58.185Z","comments":true,"path":"2015/07/17/deploy-node-js-by-shipit/","link":"","permalink":"https://notes.knovour.ninja/2015/07/17/deploy-node-js-by-shipit/","excerpt":"前置作業假設是全新的 Linux，帳號為 deploy 在 github 等託管服務中登錄 deploy server 的 ssh public key。 設定 ssh 免密碼遠端登入：在 .ssh/authorized_keys 裡貼上開發機的 ssh public key。 如有需要，將 server 裡的 global package 裝好，如 bower、sails、grunt-cli 等等。 設定 server 裡程式碼的存放位置，假設為 /usr/src。 12mkdir -p /usr/src/my-project-namechown deploy:deploy /usr/src/my-project-name","text":"前置作業假設是全新的 Linux，帳號為 deploy 在 github 等託管服務中登錄 deploy server 的 ssh public key。 設定 ssh 免密碼遠端登入：在 .ssh/authorized_keys 裡貼上開發機的 ssh public key。 如有需要，將 server 裡的 global package 裝好，如 bower、sails、grunt-cli 等等。 設定 server 裡程式碼的存放位置，假設為 /usr/src。 12mkdir -p /usr/src/my-project-namechown deploy:deploy /usr/src/my-project-name 在開發機安裝相關套件12sudo npm i shipit-cli -gnpm i shipit-deploy shipit-npm --save-dev ShipIt!在專案資料夾目錄產生 shipitfile.js 內容如下 12345678910111213141516171819module.exports = function (shipit) &#123; require('shipit-deploy')(shipit); // remote deploy require('shipit-npm')(shipit); // remote auto install npm packages var config = &#123; default: &#123; workspace: '/tmp/project-name-in-deploy-server', deployTo: '/usr/src/project-name-in-deploy-server', repositoryUrl: 'your git remote url (github, bitbucket, etc...)', ignores: ['.git', 'node_modules'], keepReleases: 2, &#125;, staging: &#123; servers: 'deploy@your-deploy-server-ip' &#125; &#125;; shipit.initConfig(config);&#125;; 輸入 shipit staging deploy 開始部署 額外命令123456789101112shipit.initConfig(config);// code 加在這行之後var current = config.default.deployTo + '/current';// shipit 會將 source code 放在 deploy server 專案資料夾裡的 current 中shipit.task('server-on', function() &#123; return shipit.remote('cd ' + current + ' &amp;&amp; bower i &amp;&amp; npm start');&#125;);shipit.task('start', function() &#123; shipit.start(['deploy', 'server-on']);&#125;); 執行 shipit staging start 基本設定的樣子 參考來源 Forget Capistrano and deploy your node.js application using Shipit（裡面是用 grunt 當範例，但我用 grunt 的方式跑不起來） Shipit shipit-deploy","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://notes.knovour.ninja/tags/node-js/"},{"name":"deploy","slug":"deploy","permalink":"https://notes.knovour.ninja/tags/deploy/"}]},{"title":"記錄幾個 Google 搜尋技巧","slug":"some-google-search-skills","date":"2015-04-15T13:43:00.000Z","updated":"2017-05-13T11:05:03.790Z","comments":true,"path":"2015/04/15/some-google-search-skills/","link":"","permalink":"https://notes.knovour.ninja/2015/04/15/some-google-search-skills/","excerpt":"記錄幾個自己在搜尋時常用到的方式 一般方式 -：排除某個關鍵字。例：ui -jquery site:：搜尋特定網站內容。例：site:medium.com node.js &quot;關鍵字&quot;：限定搜尋結果包含引號內完整字串。 額外關鍵字 alternative(s)：搜尋某個軟體或 library 有沒有類似的東西。若搜尋的是 library 相關的，搜尋結果裡的 AlternativeTo 網站則可以不用管，因為裡面舉的例子還是以軟體為主。 how (to)：搜尋一些 server 或開發環境架設時會用到 附近：搜尋 Map 時會用到。如：101 附近 餐廳","text":"記錄幾個自己在搜尋時常用到的方式 一般方式 -：排除某個關鍵字。例：ui -jquery site:：搜尋特定網站內容。例：site:medium.com node.js &quot;關鍵字&quot;：限定搜尋結果包含引號內完整字串。 額外關鍵字 alternative(s)：搜尋某個軟體或 library 有沒有類似的東西。若搜尋的是 library 相關的，搜尋結果裡的 AlternativeTo 網站則可以不用管，因為裡面舉的例子還是以軟體為主。 how (to)：搜尋一些 server 或開發環境架設時會用到 附近：搜尋 Map 時會用到。如：101 附近 餐廳 一些特殊符號的英文主要是以前剛接觸 CSS3 跟 HTML 時會找的符號 (sign 或 symbol) &gt;：greater than ~：tilde +：plus :：colon ;：semicolon -：dash、minus _：underline ,：comma .：dot •：bullet point ·：middot $：dollar #：number、pound (美式) 幾個 UI 相關元件的英文 hamburger menu：就是本 blog 左上角那三條線。 ghost button：只有 border 沒有 background-color 的按鈕。","categories":[],"tags":[{"name":"google","slug":"google","permalink":"https://notes.knovour.ninja/tags/google/"},{"name":"search","slug":"search","permalink":"https://notes.knovour.ninja/tags/search/"}]}]}